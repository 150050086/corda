package net.corda.node.flows

import co.paralleluniverse.fibers.Suspendable
import net.corda.core.flows.*
import net.corda.core.identity.Party
import net.corda.core.internal.*
import net.corda.core.messaging.startFlow
import net.corda.core.utilities.getOrThrow
import net.corda.core.utilities.unwrap
import net.corda.node.internal.CheckpointIncompatibleException
import net.corda.testing.core.ALICE_NAME
import net.corda.testing.core.BOB_NAME
import net.corda.testing.core.singleIdentity
import net.corda.testing.driver.DriverDSL
import net.corda.testing.driver.DriverParameters
import net.corda.testing.driver.NodeParameters
import net.corda.testing.driver.driver
import net.corda.testing.node.internal.CustomCordapp
import net.corda.testing.node.internal.ListenProcessDeathException
import net.corda.testing.node.internal.assertCheckpoints
import net.corda.testing.node.internal.enclosedCordapp
import org.junit.Test
import java.nio.file.Path
import java.nio.file.StandardCopyOption.REPLACE_EXISTING
import kotlin.test.assertEquals
import kotlin.test.assertFailsWith

// TraderDemoTest already has a test which checks the node can resume a flow from a checkpoint
class FlowCheckpointVersionNodeStartupCheckTest {
    companion object {
        val defaultCordapp = enclosedCordapp()
    }

    @Test
    fun `restart node with incompatible version of suspended flow due to different jar name`() {
        driver(parametersForRestartingNodes()) {
            val defaultCordappJar = createSuspendedFlowInBob()
            defaultCordappJar.renameTo("renamed-${defaultCordappJar.fileName}")

            assertBobFailsToStartWithLogMessage(
                    CheckpointIncompatibleException.FlowNotInstalledException(ReceiverFlow::class.java).message
            )
        }
    }

    @Test
    fun `restart node with incompatible version of suspended flow due to different jar hash`() {
        driver(parametersForRestartingNodes()) {
            val defaultCordappJar = createSuspendedFlowInBob()

            // The name is part of the MANIFEST so changing it is sufficient to change the jar hash
            val modifiedCordapp = defaultCordapp.copy(name = "${defaultCordapp.name}-modified")
            val modifiedCordappJar = CustomCordapp.getJarFile(modifiedCordapp)
            modifiedCordappJar.moveTo(defaultCordappJar, REPLACE_EXISTING)

            assertBobFailsToStartWithLogMessage(
                    // The part of the log message generated by CheckpointIncompatibleException.FlowVersionIncompatibleException
                    "that is incompatible with the current installed version of"
            )
        }
    }

    private fun DriverDSL.createSuspendedFlowInBob(): Path {
        val (alice, bob) = listOf(
                startNode(providedName = ALICE_NAME),
                startNode(NodeParameters(providedName = BOB_NAME, additionalCordapps = listOf(defaultCordapp)))
        ).map { it.getOrThrow() }

        alice.stop() // Stop Alice so that Bob never receives the message

        bob.rpc.startFlow(::ReceiverFlow, alice.nodeInfo.singleIdentity())
        // Wait until Bob's flow has started
        bob.rpc.stateMachinesFeed().let { it.updates.map { it.id }.startWith(it.snapshot.map { it.id }) }.toBlocking().first()
        bob.stop()
        assertCheckpoints(BOB_NAME, 1)

        return (bob.baseDirectory / "cordapps").list().single { it.toString().endsWith(".jar") }
    }

    private fun DriverDSL.assertBobFailsToStartWithLogMessage(logMessage: String) {
        assertFailsWith(ListenProcessDeathException::class) {
            startNode(NodeParameters(
                    providedName = BOB_NAME,
                    customOverrides = mapOf("devMode" to false)
            )).getOrThrow()
        }

        val logDir = baseDirectory(BOB_NAME)
        val logFile = logDir.list { it.filter { it.fileName.toString().endsWith("out.log") }.findAny().get() }
        val matchingLineCount = logFile.readLines { it.filter { line -> logMessage in line }.count() }
        assertEquals(1, matchingLineCount)
    }

    private fun parametersForRestartingNodes(): DriverParameters {
        return DriverParameters(
                startNodesInProcess = false, // Start nodes in separate processes to ensure CordappLoader is not shared between restarts
                inMemoryDB = false, // Ensure database is persisted between node restarts so we can keep suspended flows
                cordappsForAllNodes = emptyList(),
                notarySpecs = emptyList()
        )
    }

    @InitiatingFlow
    @StartableByRPC
    class ReceiverFlow(private val otherParty: Party) : FlowLogic<String>() {
        @Suspendable
        override fun call(): String = initiateFlow(otherParty).receive<String>().unwrap { it }
    }

    @InitiatedBy(ReceiverFlow::class)
    class SenderFlow(private val otherSide: FlowSession) : FlowLogic<Unit>() {
        @Suspendable
        override fun call() = otherSide.send("Hello!")
    }
}
